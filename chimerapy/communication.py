# Built-in Imports
from typing import Sequence, Dict, Any, Union, List, Optional
import sys
import collections
import os
import curses
import time
import threading
import multiprocessing as mp
import queue
import pathlib
import signal

# Third-Party Imports
import psutil
import pandas as pd

# Internal Imports
from chimerapy.core.tools import threaded, clear_queue, PortableQueue,  get_threads_cpu_percent

class RunnerCommunication():

    def __init__(
            self,
            object:'Runner',
            message_to_loading_queue:PortableQueue,
            message_to_logging_queue:PortableQueue,
            message_from_loading_queue:PortableQueue,
            message_from_logging_queue:PortableQueue
        ):

        # Storing inputs
        self.object = object
        self.message_to_loading_queue = message_to_loading_queue
        self.message_to_logging_queue = message_to_logging_queue
        self.message_from_loading_queue = message_from_loading_queue
        self.message_from_logging_queue = message_from_logging_queue
        
        # Define the protocol for processing messages from the loader and logger
        self.respond_message_protocol = {
            'LOADER':{
                'UPDATE': {
                    'TIMETRACK': self.respond_loader_message_timetrack,
                    'COUNTER': self.respond_loader_message_counter
                },
                'META': {
                    'END': self.respond_loader_message_end
                }
            },
            'LOGGER':{
                'UPDATE': {
                    'COUNTER': self.respond_logger_message_counter
                },
                'META': {
                    'END': self.respond_logger_message_end
                }
            }
        }

    def message_pause_loader(self):
        """Message to pause the ``Loader``."""

        # Sending the message to loader to pause!
        pause_message = {
            'header': 'META',
            'body': {
                'type': 'PAUSE',
                'content': {},
            }
        }
        self.message_to_loading_queue.put(pause_message)
    
    def message_resume_loader(self):
        """Message to resume the ``Loader``."""

        # Sending the message to loader to pause!
        pause_message = {
            'header': 'META',
            'body': {
                'type': 'RESUME',
                'content': {},
            }
        }
        self.message_to_loading_queue.put(pause_message)

    def message_end_loading_and_logging(self):
        """Message to terminate the ``Loader`` and ``Logging``."""

        # Sending message to loader and logger to stop!
        end_message = {
            'header': 'META',
            'body': {
                'type': 'END',
                'content': {},
            }
        }
        self.message_to_loading_queue.put(end_message)
        self.message_to_logging_queue.put(end_message)

    def respond_loader_message_timetrack(self, timetrack:pd.DataFrame, windows:list):
        """Respond to the retrieved message with initialization info.

        Args:
            timetrack (pd.DataFrame): The global timetrack generated by
            the ``Collector``.

            windows (list): List of the windows with their start and end
            times.

        """
        self.object.timetrack = timetrack
        self.object.num_of_windows = len(windows)

    def respond_loader_message_counter(
            self, 
            uuid:str, 
            loading_window:int, 
            data_memory_usage:int
        ):
        """Respond to update in ``Loader`` window counter.

        This message is vital for its memory usage information. We need
        to track this memory consumption to when we need to limit memory
        usage.

        Args:
            uuid (str): The unique id of the loaded data. This id helps
            track the memory of each loaded data chunk and note when
            the memory has been return to the OS.

            loading_window: The id of the loading window.

            data_memory_usage: The number of bytes used by the loaded
            data chunk.

        """
        self.latest_window_loaded = loading_window
        self.object.loading_queue_memory_chunks[uuid] = data_memory_usage

    def respond_logger_message_counter(
            self, 
            num_of_logged_data:int, 
            uuid:str
        ):
        """Respond to update in ``Logger`` logged data.

        Args:
            num_of_logged_data (int): The number of logged data chunks.
            This is used in the TUI to provide a overview of the system.

            uuid (str): The unique id of the logged data chunk. This id
            helps track the memory deleted by the logger.

        """
        self.object.num_of_logged_data = num_of_logged_data

        # Sometimes the uuid has not been added yet so we need to wait
        while uuid not in self.object.logging_queue_memory_chunks:
            time.sleep(0.01)

        del self.object.logging_queue_memory_chunks[uuid]

    def respond_loader_message_end(self):
        """Respond to the ``Loader`` inform that it has ended."""
        self.loader_finished = True

    def respond_logger_message_end(self):
        """Respond to the ``Logger`` inform that it has ended."""
        self.logger_finished = True
    
    @threaded
    def check_loader_messages(self):
        """Message thread checks for new messages and limit memory usage.
        
        The ``Loader`` message queues are checked frequently and if 
        there is a new message, then the corresponding function is 
        executed. These functions are defined by the protocols layed out 
        in the ``__init__``. 

        Given the memory usage information from the ``Loader`` and 
        ``Logger``, this thread enforces the memory limit by pausing and
        resuming the operation of each process. ``Loader`` consumes
        memory while ``Logger`` frees the RAM memory back to the system 
        to use.

        """
        # Set the flag to check if new message
        loading_message = None
        loading_message_new = False
        
        # Constantly check for messages
        while not self.object.thread_exit.is_set():

            # Checking the loading message queue
            try:
                loading_message = self.message_from_loading_queue.get(timeout=0.1)
                loading_message_new = True
            except queue.Empty:
                loading_message_new = False

            # Processing new loading messages
            if loading_message_new:

                # Printing if verbose
                if self.object.verbose:
                    print("NEW LOADING MESSAGE: ", loading_message)

                # Obtain the function and execute it, by passing the 
                # message
                func = self.respond_message_protocol['LOADER'][loading_message['header']][loading_message['body']['type']]

                # Execute the function and pass the message
                func(**loading_message['body']['content'])

            # Check if the memory limit is passed
            self.object.total_memory_used = self.object.memory_usage_factor * (sum(list(self.object.logging_queue_memory_chunks.values())) + sum(list(self.object.loading_queue_memory_chunks.values())))

            # Reporting memory usage if debugging
            if self.object.verbose:
                print(f"TMU: {self.object.total_memory_used}, AVAILABLE: {self.object.total_available_memory}, RATIO: {self.object.total_memory_used / self.object.total_available_memory}")

            if self.object.total_memory_used > self.object.total_available_memory and not self.object.loader_paused:
                # Pause the loading and wait until memory is cleared!
                self.message_pause_loader()
                self.loader_paused = True
            elif self.object.total_memory_used < self.object.total_available_memory and self.object.loader_paused:
                # resume the loading and wait until memory is cleared!
                self.message_resume_loader()
                self.object.loader_paused = False

    @threaded
    def check_logger_messages(self):
        """Message thread checks for new messages and limit memory usage.
        
        The ``Logger`` message queues are checked frequently and if 
        there is a new message, then the corresponding function is 
        executed. These functions are defined by the protocols layed out 
        in the ``__init__``. 

        Given the memory usage information from the ``Loader`` and 
        ``Logger``, this thread enforces the memory limit by pausing and
        resuming the operation of each process. ``Loader`` consumes
        memory while ``Logger`` frees the RAM memory back to the system 
        to use.

        """
        # Set the flag to check if new message
        logging_message = None
        logging_message_new = False
        
        # Constantly check for messages
        while not self.object.thread_exit.is_set():
            
            # Checking the logging message queue
            try:
                logging_message = self.message_from_logging_queue.get(timeout=0.1)
                logging_message_new = True
            except queue.Empty:
                logging_message_new = False

            # Processing new sorting messages
            if logging_message_new:

                # Obtain the function and execute it, by passing the 
                # message
                func = self.respond_message_protocol['LOGGER'][logging_message['header']][logging_message['body']['type']]

                # Execute the function and pass the message
                func(**logging_message['body']['content'])
